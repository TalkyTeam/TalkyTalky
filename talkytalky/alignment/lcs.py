from talkytalky.alignment.AlignedItem import AlignedItem
from talkytalky.util.string import contains_letters


def lcs(html_document, transcript, string_equality):
    """
    Set up and call the longest common subsequence method to get the common words in
    the transcript and HTML document
    :param html_document:
    :param transcript:
    :param string_equality:
    :return: List of LCS objects that contain paired words
    """
    memo_table = lcs_memo(html_document, transcript, string_equality)
    #print([memo_table, html_document, transcript, len(html_document.items), len(transcript.items)])
    aligned_word_list = backtrack(memo_table, html_document, transcript, len(html_document.items), len(transcript.items), string_equality)
    return aligned_word_list


def lcs_memo(html_document, transcript, string_equality):
    """
    Canonical example of dynamic programming
    Literally taken from Wikipedia, although they chose C# for some reason:
    https://en.wikipedia.org/wiki/Longest_common_subsequence_problem
    and here
    https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/
    :param html_document: Data structure with sentences and items (words)
    :param transcript:
    :param string_equality:
    :return:
    """
    # find the length of the strings
    html_num_words = len(html_document.items)
    print("# HTML words " + str(html_num_words))
    transcript_num_words = len(transcript.items)
    print("# transcript words " + str(transcript_num_words))

    # Create the dynamic programming table
    lcs_memo_table = [[0] * (transcript_num_words + 1) for html_word_index in range(html_num_words + 1)]
    # print(lcs_memo_table)

    '''
    Following steps build lcs_memo_table[html_num_words + 1][transcript_num_words + 1] in bottom up fashion 
    Note: lcs_memo_table[html_word_index][transcript_word_index] contains length of LCS of X[0..html_word_index-1] 
    and Y[0..transcript_word_index-1]
    '''
    for i in range(1,html_num_words):
        for j in range(1,transcript_num_words):
            if i == 0 or j == 0:
                lcs_memo_table[i][j] = 0
            elif not(contains_letters(html_document.items[i - 1].content)) \
                     or not(contains_letters(transcript.items[j - 1].content)):
                lcs_memo_table[i][j] = \
                    max(lcs_memo_table[i][j - 1],
                    lcs_memo_table[i - 1][j])
            elif string_equality(html_document.items[i - 1].content,
                             transcript.items[j - 1].content):
                lcs_memo_table[i][j] = \
                    (lcs_memo_table[i - 1][j - 1]) + 1
            else:
                # lcs_memo_table[html_num_words][transcript_num_words] contains the length of LCS of
                # html_document.items[0..transcript_num_words-1] transcript.items Y[0..html_num_words-1]
                lcs_memo_table[i][j] = \
                    max(lcs_memo_table[i][j - 1],
                        lcs_memo_table[i - 1][j])

    print("Longest substring has number terms: %s", str(lcs_memo_table[html_num_words - 1][transcript_num_words - 1]))
    return lcs_memo_table


def backtrack(lcs_memo_table, html_document, transcript, html_num_words, transcript_num_words, string_equality):
    """
    Because the recursive backtrack literally ran out of Python stack...
    See https://www.geeksforgeeks.org/printing-longest-common-subsequence/
    :param lcs_memo_table: Table generated by lcs_memo
    :param html_document: Data structure containing HTML doc sentences and items (words)
    :param transcript: Data structure containing transcript sentences and items
    :param html_num_words: # of words in the HTML
    :param transcript_num_words: # of words in the transcripts
    :param string_equality: A function that tells you whether 2 strings are equal (can be fuzzy)
    :return: A list of LCS objects which pair words between the transcript and HTML
    """
    i = html_num_words
    j = transcript_num_words

    ss_ind = lcs_memo_table[html_num_words - 1][transcript_num_words - 1]
    subsequence = []

    while i > 0 and j > 0:
        if string_equality(html_document.items[i - 1].content,
                           transcript.items[j - 1].content):
            new_lcs = AlignedItem()
            new_lcs.html_item = html_document.items[i - 1]
            new_lcs.trans_item = transcript.items[j - 1]
            new_lcs.html_item.best_transcript_match = new_lcs.trans_item
            subsequence.insert(0,new_lcs)
            i -= 1
            j -= 1
            ss_ind -= 1
        elif lcs_memo_table[i - 1][j] > lcs_memo_table[i][j - 1]:
            i -= 1
        else:
            j -= 1

    return subsequence

def backtrack_recursive(lcs_memo_table, html_document, transcript, i, j, string_equality):
    """
    Literally from Wikipedia.  Classic.
    https://en.wikipedia.org/wiki/Longest_common_subsequence_problem
    :param lcs_memo_table: Table generated by lcs_memo
    :param html_document: Data structure containing HTML doc sentences and items (words)
    :param transcript: Data structure containing transcript sentences and items
    :param html_num_words: # of words in the HTML
    :param transcript_num_words: # of words in the transcripts
    :param string_equality: A function that tells you whether 2 strings are equal (can be fuzzy)
    :return: A list of LCS objects which pair words between the transcript and HTML
    """
    if i == 0 or j == 0:
        return []
    if string_equality(html_document.items[i - 1].content,
                       transcript.items[j - 1].content):
        smaller = backtrack_recursive(lcs_memo_table, html_document, transcript, i - 1, j - 1,
                                      string_equality)
        new_lcs = AlignedItem()
        new_lcs.html_item = html_document.items[i - 1]
        new_lcs.trans_item = transcript.items[j - 1]
        new_lcs.html_item.best_transcript_match = new_lcs.trans_item
        smaller.append(new_lcs)
        return smaller
    if lcs_memo_table[i][j - 1] > lcs_memo_table[i - 1][
        j]:
        return backtrack_recursive(lcs_memo_table, html_document, transcript, i, j - 1,
                                   string_equality)
    return backtrack_recursive(lcs_memo_table, html_document, transcript, i - 1, j,
                               string_equality)
